<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>sinter</title>
<style>
body {
  margin: 0px 0px 0px 0px;
  overflow-x: hidden;
  overflow-y: hidden;
}
#chooseDeckSize {
  background: black;
  color: white;
}
.bigMenu {
  font-size: 30px;
}
</style>
<script type="text/javascript">
// are we overusing globals
var menu;
var canv;
var g;
var winW = 0;
var winH = 0;
var cardBitCounts = [];
var deckOrig = [];
var deck = [];
var rowCounts = [];
var cardW = 0;
var cardH = 0;
var dealInitially = 0;
var deckPos = 0;
var cardsOut = [[]];
var dealCardW = 0;
// gfx settings
var cardBg = "#000";
var cardFg = "#FFF";
var winBg = "#070";
var omni = 24;
var bitW = 2 * omni;
var bitH = 2 * omni;
var propSpacing = omni;
var cardMarginW = omni;
var cardMarginH = omni;
var tableMarginW = omni / 2;
var tableMarginH = omni / 2;
var cardSepW = omni / 2;
var cardSepH = omni / 2;
function init() {
  menu = document.getElementById("chooseDeckSize");
  canv = document.getElementById("canvas");
  g = canv.getContext("2d");
  initWin();
  var deckTypeStr = getParam("d");
  if (deckTypeStr) {
    menu.style.display = "none";
    // fixme: hack; should decode
    //cardBitCounts = deckTypeStr.split(",");
    cardBitCounts = deckTypeStr.split("%2C").slice(0, 32);
    for (var i in cardBitCounts) {
      var n = Number(cardBitCounts[i]);
      if (isNaN(n) || n < 2 || n > 16) {
        n = 2;
      }
      cardBitCounts[i] = n;
    }
    initGameType();
    initGame();
  }
  window.onresize = function(){
    // todo: do something if cards go off bottom of screen
    initWin();
    var cardsOutOld = cardsOut;
    var dealCardWOld = dealCardW;
    calcDealCardW();
    for (var j = 0; j < cardsOutOld.length; j++) {
      for (var i = 0; i < dealCardWOld; i++) {
        if (cardsOutOld[j][i]) {
          placeCard(cardsOutOld[j][i]);
        }
      }
    }
    return true;
  }
}
function initWin() {
  winW = window.innerWidth;
  winH = window.innerHeight;
  canv.width = winW;
  canv.height = winH;
  g.fillStyle = winBg;
  g.fillRect(0, 0, winW, winH);
}
function initGameType() {
  rowCounts = [];
  for (var i in cardBitCounts) {
    var c = cardBitCounts[i];
    var cTrips = Math.floor(c / 3);
    switch (c % 3) {
    case 0:
      rowCounts[i] = replicate(cTrips, 3);
      break;
    case 1:
      rowCounts[i] = [2].concat(replicate(cTrips - 1, 3), [2]);
      break;
    case 2:
      rowCounts[i] = replicate(cTrips, 3).concat(2);
      break;
    }
  }

  var b = [0, 1];
  deckOrig = arrSequence(
    map(function(x){return tail(arrSequence(replicateArr(x, b)));},
    cardBitCounts));

  cardH = cardMarginH * 2;
  var maxRowCount = 0;
  for (var i in rowCounts) {
    var counts = rowCounts[i];
    for (var j in counts) {
      count = counts[j];
      if (count > maxRowCount) {
        maxRowCount = count;
      }
      cardH += bitH;
    }
    cardH += propSpacing;
  }
  cardH -= propSpacing;
  cardW = maxRowCount * bitW + 2 * cardMarginW;

  // todo: cooler heuristic?
  dealInitially = Math.max(3, Math.round(12 * deckOrig.length / 81));

  calcDealCardW();
}
function calcDealCardW() {
  dealCardW = Math.floor(
    (winW - 2 * tableMarginW + cardSepW) / (cardW + cardSepW));
  cardsOut = replicateArr(Math.ceil(deckOrig.length / dealCardW), 
    replicate(dealCardW, false));
}
function initGame() {
  deck = arrCopy(deckOrig);
  shuffle(deck);
  for (i = 0; i < dealInitially; i++) {
    dealCard();
  }
}
function placeCard(card) {
  for (var j = 0; ; j++) {
    for (var i = 0; i < dealCardW; i++) {
      if (!cardsOut[j][i]) {
        cardsOut[j][i] = card;
        drawCard(card,
          tableMarginW + i * (cardW + cardSepW), 
          tableMarginH + j * (cardH + cardSepH));
        return;
      }
    }
  }
}
function dealCard() {
  if (deckPos >= deck.length) {
    return;
  }
  placeCard(deck[deckPos]);
  deckPos++;
}
function drawCard(card, x, y) {
  g.fillStyle = cardBg;
  g.strokeStyle = cardFg;
  g.fillRect(x, y, cardW, cardH);
  g.strokeRect(x, y, cardW, cardH);

  var curY = cardMarginH;
  g.fillStyle = cardFg;
  g.strokeStyle = "#888";
  for (var i in rowCounts) {
    var counts = rowCounts[i];
    var curCol = 0;
    for (var j in counts) {
      var count = counts[j];
      for (var k = 0; k < count; k++) {
        var bitX = x + cardW / 2 + (k - count / 2) * bitW;
        if (card[i][curCol]) {
          g.fillRect(bitX, y + curY, bitW, bitH);
        }
        g.strokeRect(bitX, y + curY, bitW, bitH);
        curCol++;
      }
      curY += bitH;
    }
    curY += propSpacing;
  }
}

//
// gen util
//

// a uniform random float in [a, b)
function randFloat(a, b) {
  return Math.random() * (b - a) + a;
}
// a uniform random int in [a, b]
function randInt(a, b) {
  return Math.floor(randFloat(a, b + 1));
}
function shuffle(a) {
  var i = a.length;
  if (i == 0) {
    return [];
  }
  while (--i) {
    var j = randInt(0, i);
    var tmp = a[i];
    a[i] = a[j];
    a[j] = tmp;
  }
}
function getParam(name) {
  // fixme: make this more correct and do decoding?
  name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
  var regexS = "[\\?&]" + name + "=([^&#]*)";
  var regex = new RegExp(regexS);
  var results = regex.exec(window.location.href);
  if (results == null) {
    return null;
  } else {
    return results[1];
  }
}

//
// missing (i think) functions ported from haskell, and hacks
//

function arrSequence(arrs) {
  if (arrs.length == 0) {
    return [[]];
  }
  var arr0 = arrs[0];
  var seqRest = arrSequence(tail(arrs));
  var k = 0;
  var ret = [];
  for (var i in arr0) {
    for (var j in seqRest) {
      ret[k] = [arr0[i]].concat(seqRest[j]);
      k++;
    }
  }
  return ret;
}
function replicate(n, x) {
  var ret = [];
  for (var i = 0; i < n; i++) {
     ret[i] = x;
  }
  return ret;
}
// fixme: duplication..?
function replicateArr(n, x) {
  var ret = [];
  for (var i = 0; i < n; i++) {
     ret[i] = arrCopy(x);
  }
  return ret;
}
function tail(l) {
  return l.slice(1);
}
function map(f, xs) {
  var ret = [];
  for (i in xs) {
    ret[i] = f(xs[i]);
  }
  return ret;
}
function concat(arrs) {
  if (arrs.length == 0) {
    return [];
  }
  return arrs[0].concat(concat(tail(arrs)));
}
function arrCopy(arr) {
  return arr.slice(0);
}
</script>
</head>
<body onload="init();">
<div id="chooseDeckSize" class="bigMenu">
<form>
Choose Deck Size
<select name="d" class="bigMenu">
<option value="3">7</option>
<option value="2,2">9</option>
<option value="4">15</option>
<option value="2,3">21</option>
<option value="2,2,2">27</option>
<option value="5">31</option>
<option value="2,4">45</option>
<option value="6">63</option>
<option value="2,2,2,2">81</option>
<option value="2,5" selected>93</option>
<option value="3,4">105</option>
<option value="7">127</option>
<option value="2,2,4">135</option>
<option value="2,2,2,3">189</option>
<option value="3,5">217</option>
<option value="2,2,2,2,2">243</option>
<option value="8">255</option>
</select>
<input class="bigMenu" type="submit" value="Go" />
</form>
</div>
<canvas id="canvas" width=0 height=0 onmousedown="return false;"></canvas>
</body>
</html>
